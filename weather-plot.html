<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Weather Data</title>

  <link rel="stylesheet" href="style.css">

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

  <!-- Zoom plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>

  <style>
    body { text-align: center; }

    .container {
      max-width: 1400px;
      margin: auto;
      padding: 1.5rem;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 2rem;
      margin: 1.5rem 0 2rem;
      flex-wrap: wrap;
    }

    .chart-wrapper {
      width: 66vw;
      height: 340px;
      margin: 2.5rem auto;
    }

    .error { color: crimson; font-weight: 600; }
    .loading { color: #555; font-style: italic; }
  </style>
</head>

<body>
<div class="container">
  <h1>Weather Data</h1>
  <p>Local environmental measurements</p>

  <div class="controls">
    <label>
      <input type="checkbox" id="rangeToggle">
      Show week (unchecked = day)
    </label>

    <label>
      <input type="checkbox" id="unitToggle">
      Use °F (unchecked = °C)
    </label>
  </div>

  <p id="status" aria-live="polite"></p>

  <div class="chart-wrapper"><canvas id="tempChart"></canvas></div>
  <div class="chart-wrapper"><canvas id="pressureChart"></canvas></div>
  <div class="chart-wrapper"><canvas id="humidityChart"></canvas></div>
</div>

<script>
"use strict";

/* -------------------- Constants -------------------- */

const RANGE = { DAY: "day", WEEK: "week" };
const UNIT  = { C: "c", F: "f" };

const DATA_URLS = {
  day:  "https://raw.githubusercontent.com/mr-hazmat/RPi_Compact-Weather-Station/main/docs/data/weather-last-day.csv",
  week: "https://raw.githubusercontent.com/mr-hazmat/RPi_Compact-Weather-Station/main/docs/data/weather-last-week.csv"
};

/* -------------------- State -------------------- */

const state = { range: RANGE.DAY, unit: UNIT.C };

const els = {
  rangeToggle: document.getElementById("rangeToggle"),
  unitToggle: document.getElementById("unitToggle"),
  status: document.getElementById("status"),
  temp: document.getElementById("tempChart"),
  pressure: document.getElementById("pressureChart"),
  humidity: document.getElementById("humidityChart")
};

let charts = {};

/* -------------------- Helpers -------------------- */

function setStatus(msg = "", cls = "") {
  els.status.textContent = msg;
  els.status.className = cls;
}

async function loadCSV(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error("Failed to load CSV");

  const text = await res.text();
  const lines = text.trim().split("\n");
  const headers = lines.shift().split(",");

  return lines.map(l => {
    const v = l.split(",");
    return Object.fromEntries(headers.map((h, i) => [h, v[i]]));
  });
}

function updateOrCreateChart(chart, canvas, label, data, color, timeUnit, yOpts) {
  if (chart) {
    chart.data.datasets[0].label = label;
    chart.data.datasets[0].data = data;
    chart.options.scales.x.time.unit = timeUnit;
    chart.update("none");
    return chart;
  }

  return new Chart(canvas.getContext("2d"), {
    type: "line",
    data: {
      datasets: [{
        label,
        data,
        parsing: false,
        borderColor: color,
        borderWidth: 2,
        pointRadius: 0
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      scales: {
        x: {
          type: "time",
          time: { unit: timeUnit },
          ticks: { autoSkip: true, maxRotation: 0 }
        },
        y: yOpts
      },
      plugins: {
        zoom: {
          zoom: {
            wheel: {
              enabled: true,
              modifierKey: null
            },
            mode: "x"
          },
          pan: {
            enabled: false
          }
        }
      }
    }
  });
}

/* -------------------- Render -------------------- */

async function render() {
  setStatus("Loading…", "loading");

  try {
    const rows = await loadCSV(DATA_URLS[state.range]);
    const timeUnit = state.range === RANGE.DAY ? "hour" : "day";

    const parsed = rows.map(r => {
      const t = new Date(r.timestamp);
      if (Number.isNaN(t)) return null;

      const tc = parseFloat(r.temp_c);
      const tf = parseFloat(r.temp_f);
      const temp = state.unit === UNIT.C ? tc : (Number.isFinite(tf) ? tf : tc * 9/5 + 32);

      const p = parseFloat(r.pressure_hpa);
      const h = parseFloat(r.humidity);

      if (![temp, p, h].every(Number.isFinite)) return null;
      return { t, temp, p, h };
    }).filter(Boolean);

    charts.temp = updateOrCreateChart(
      charts.temp,
      els.temp,
      `Temperature (${state.unit === UNIT.C ? "°C" : "°F"})`,
      parsed.map(d => ({ x: d.t, y: d.temp })),
      "crimson",
      timeUnit,
      {
        suggestedMin: state.unit === UNIT.C ? -10 : 14,
        suggestedMax: state.unit === UNIT.C ? 40 : 104,
        ticks: { maxTicksLimit: 6 }
      }
    );

    charts.pressure = updateOrCreateChart(
      charts.pressure,
      els.pressure,
      "Pressure (hPa)",
      parsed.map(d => ({ x: d.t, y: d.p })),
      "royalblue",
      timeUnit,
      {
        suggestedMin: 950,
        suggestedMax: 1050,
        ticks: { maxTicksLimit: 6 }
      }
    );

    charts.humidity = updateOrCreateChart(
      charts.humidity,
      els.humidity,
      "Humidity (%)",
      parsed.map(d => ({ x: d.t, y: d.h })),
      "seagreen",
      timeUnit,
      {
        min: 0,
        max: 100,
        ticks: {
          callback: v => v + "%",
          maxTicksLimit: 6
        }
      }
    );

    setStatus();

  } catch (err) {
    setStatus(err.message, "error");
  }
}

/* -------------------- Events -------------------- */

els.rangeToggle.addEventListener("change", e => {
  state.range = e.target.checked ? RANGE.WEEK : RANGE.DAY;
  Object.values(charts).forEach(c => c?.resetZoom());
  render();
});

els.unitToggle.addEventListener("change", e => {
  state.unit = e.target.checked ? UNIT.F : UNIT.C;
  Object.values(charts).forEach(c => c?.resetZoom());
  render();
});

render();
</script>
</body>
</html>

